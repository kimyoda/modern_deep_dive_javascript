# 12.7 다양한 함수의 형태

---

#### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 ㅈ함수를 즉시 실행 함수라 한다.
- 즉시 실행 함수는 한번만 호출되고 다시 호출할 수 없다.

예제 12-34

```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
})();
```

- 즉시 실행 함수는 이름이 없는 익명함수를 사용하는 것이 일반적이다.
- 함수 이름이 있는 기명 즉시 실행 함수도 사용할 수 있다.
- 그룹 연산자 (...) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가
- 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자, 즉시 실행 함수를 다시 호출할 수 없다.

예제 12-35

```js
// 기명 즉시 실행 함수
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
})();

foo(); // ReferenceError
```

- 즉시 실행 함수는 그룹 연산자 (...)로 감싸야 한다. 그렇지 않으면 다음과 같이 에러가 발생한다.

예제 12-36

```js
function () { // SyntaxError: Function statmenet
  // ...
}();
```

- 에러가 발생하는 이유는 함수 정의가 함수 선언문의 형시에 맞지 않기 때문이다.
- 함수 선언문은 이름을 생략할 수 없다.

예제 12-37

```js
function foo() {
  // ..
}(); // SyntaxError: Unexpected token ')'
```

- 자바스크립트 엔진이 암묵적으로 수행하는 세미콜론 자동 삽입 기능에 의해 함수 선언문이 끝나는 위치, 함수 코드 블록의 닫는 중괄호 뒤에 ";"이 암묵적으로 추가되기 때문

예제 12-38

```js
funciton foo() {}(); // => function foo () {}; ();
```

- 다라서 함수 선언문 뒤의 (...)는 함수 호출 연산자가 아닌 그룹 연산자로 해석된다.
- 그룹 연산자에 피연산자가 없기에 에러가 발생한다.

예제 12-39

```js
(); // Unexpected oken ')'
```

- 그룹 연산자의 피연산자는 값으로 평가, 기명 또는 무명 함수를 그룹 연산자로 감싸고 함수 리터럴로 평가하여 함수 객체가 된다.

예제 12-40

```js
console.log(typeof function f() {}); // function
console.log(typeof function () {}); // function
```

- 그룹 연산자로 함수를 묶은 이유는 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.
- 함수 리터럴을 평가해서 함수 객체를 생성하면 그룹 연산자 이외의 연산자를 사용해도 좋다.

예제 12-41

```js
(function () {
  // ...
})();

(function () {
  // ...
})();

!(function () {
  // ...
})();

+(function () {
  // ...
})();
```

- 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수 있다.

예제 12-42

```js
// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

console.log(res); // 15

// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res); // 15
```

- 즉시 실행 함수 내에 코드를 모아두면 변수나 함수 이름의 충동을 방지할 수 있다.
-

---

#### 12.7.2 재귀함수

- 원시메모리 공간의 크기를 결정해야 한다.
- 문자열은 독특한 특징이 있다.
- 1개의 문자는 2바이트의 메모리 공간에 저장되어 문자에 따라 필요한 메로리 공간의 크기가 결정된다.
- 1개의 문자는 2바이트, 10개의 문자는 20바이트가 필요하다.

예제 11-2

```js
// 문자열은 0개 이상의 문자로 이뤄진 집합이다.
var str1 = ""; // 0개 문자로 이뤄진 문자열
var str2 = "Hello"; // 5개의 문자로 이뤄진 문자열
```

- 자스는 원시 타입인 문자열 타입을 제공한다.
- 문자열은 원시 타입이고 변경 불가능하다.
- 문자열이 생성된 이후 변경할 수 없다.

예제 11 - 3

```js
var str = "Hello";
str = "world";
```

- 첫번째 문이 실행되면 문자열 "Hello"가 생성
- 식별자 str은 문자열 "Hello"가 저장된 메모리 공간의 첫 번째 메모리 셀 주소를 가리킨다.
- 두번째 문 실행 -> "Hello"를 수정 X, 새로운 문자열 "world"를 메모리에 생성, 식별자 str은 이것을 가리킨다.
- 문자열 "Hello", "World"는 모두 메모리에 존재한다.
- 문자열은 유사 배열 객체고 이터러블로 배열과 유사하게 각 문자에 접근할 수 있다.

**📖 유사 배열 객체**

> 💡
> **유사 배열 객체(Array-like Object)란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.** > **문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있고, length 프로퍼티를 갖기에 유사 배열 객체이고 for 문으로 순회할수도 있다.**
>
> 예제 11-4
>
> ```javascript
> var str = "string";
>
> // 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
> console.log(str[0]); // s
>
> // 원시 값인 문자열이 객체로 동작한다.
> console.log(str.length); // 6
> console.log(str.toUpperCase()); // STRING
> ```
>
> 갑자기 원시 값인 문자열이 객체일 수도 있다니 혼란스러울 수 있다. 원시 값을 객체처럼 사용하면 원시 값을 감싸는 **래퍼 객체(Wrapper Object)**로 자동 변환된다.

예제 11-5

```js
var str = "string";

// 문자열은 유사 배열, 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 문자열은 원시 값으로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = "S";

console.log(str); // string
```

- str[0] = 'S' 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
- 문자열은 변경 불가능한 값이다.
- 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없다.
- 원시 값은 어떤일이 있어도 불변하여 데이터의 신뢰성을 보장한다.
- 변수에 새로운 문자열을 재할당하는 것은 가능하고, 기존 문자열 변경이 아닌 새로운 문자열을 새롭게 할당하는 것이다.

-

#### 11.1.3 값에 의한 전달

예제 11-6

```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- score 변수에 숫자 값 80을 할당한다. copy 변수에 socre 변수 할당 -> score 변수에 새로운 숫자 값 100을 재할당한다면 copy는?
- copy = score 에서 score는 80으로 평가되고 copy 변수에도 80이 할당한다. 새로운 숫자 값이 80이 생성되어 할당된다.
- 변수에 원시 값을 갖는 변수를 할당 -> 할당받는 변수에 할당되는 변수의 원시 값이 복사되어 전달.
- 이를 **값에 의한 전달**이라 한다.
- copy 변수 - 원시 값 score 변수 할당 -> 할당받는 변수 copy에 할당되는 변수 score의 원시 값 80이 복사되어 전달된다.

예제 11-7

```js
// copy 변수에 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true
```

- score 변수와 copy 변수는 80을 갖는다는 점에서 동일하다.
- 하지만 score 변수와 copy변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
  ![alt text](image-copy.png)

- score 변수의 값을 변경해보자
  예제 11-8

```js
var score = 80;

// copy 변수에는 score 변수의 값이 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy); //100 80
console.log(score === copy); // false
```

- score 변수, copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
- 변수 score 변수의 값을 변경해도 copy 변수에 영향을 주지 않는다.
  ![alt text](image-3.webp)

- 위 그림에서 변수에 원시 값을 갖는 변수를 할당 -> 원시 값이 복사되는 것으로 표현
- 하지만, 변수에 원시 값을 갖는 변수를 할당하는 시점에 두 변수가 같은 원시 값을 참조하다가 한쪽의 변수에 재할당이 이뤄질 때 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수 있다.
- 변수에는 값 전달 X / 메모리 주소가 전달
- 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름이다.
- 값은 메모리 공간에 저장, 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억한다.
- 식별자는 메모리 주소에 붙인 이름이라고 볼 수 있다.

예제 11-9

```js
var x = 10;
```

- 할당 연산자는 숫자 값 10이 저장된 메모리 공간의 주소를 전달한다.
- 식별자 x는 메모리 공간에 저장된 값 10을 식별한다.

예제 11-10

```js
var copy = score;
```

- score는 식별자 표현식으로 80으로 평가된다.
  1. 새로운 80을 생성(복사)해서 메모리 주소를 전달한다. 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.
  2. socre 변수값 80의 메모리 주소를 그대로 전달한다. 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.

**"값에 의한 전달""도 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다**
변수 할당 시점이든, 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 재할당을 통해 값을 변경해도 서로 간섭할 수 없다.
